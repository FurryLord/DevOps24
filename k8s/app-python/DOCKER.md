## Best practices


1. **Use a precise version of the base image and language**:
   - The Dockerfile starts with a `FROM` directive specifying `python:3.9-slim`. This ensures that the base image used is a specific version of Python (3.9) and a slim variant, which contains only essential components.

2. **Create a non-root user and set permissions**:
   - The Dockerfile creates a non-root user `appuser` using the `useradd` command to improve security by running the application with reduced privileges.
   - It also creates the `/app` directory and sets its ownership to the `appuser` to ensure that the application files are stored in a directory with appropriate permissions.
  
3. **Layer Sanity**
    - The Dockerfile arranges all instructions rationally to reduce the number of layers that are produced, making the final Docker image more effective and controllable.
  
4. **.dockerignore** 
   - To ensure that sensitive data and superfluous files are not included in the Docker image, we use a `.dockerignore` file to exclude extraneous files and folders from the build context.

5. **Set the working directory in the container**:
   - The `WORKDIR` directive sets the working directory inside the container to `/app`, ensuring that subsequent commands are executed in the correct directory context.

6. **Copy only necessary files**:
   - The `COPY` directive copies only the necessary files (`requirements.txt` and `app.py`) into the `/app` directory within the Docker image. This reduces the size of the image and minimizes the attack surface.

7. **Make port 5000 available**:
   - The `EXPOSE` directive exposes port 5000, which is typically used by Flask applications, allowing external access to the application running inside the container.

8. **Configure logging directory**:
   - The Dockerfile creates a `/app/logs` directory inside the container to store log files generated by the application. This separates logs from application code and ensures proper organization.


