
```bash
$ kubectl get po,sts,svc,pvc    
NAME                                        READY   STATUS             RESTARTS        AGE
pod/app-python-0                            1/1     Running            1 (6m23s ago)   8m49s
pod/app-python-1                            1/1     Running            1 (6m23s ago)   8m49s
pod/app-python-deployment-c9d45f669-jndhr   0/1     CrashLoopBackOff   1 (13s ago)     31s
pod/app-python-deployment-c9d45f669-qlfmz   0/1     CrashLoopBackOff   7 (2m15s ago)   31h
pod/app-python-deployment-c9d45f669-txsfx   0/1     CrashLoopBackOff   7 (2m21s ago)   31h

NAME                          READY   AGE
statefulset.apps/app-python   2/2     9m30s

NAME                 TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
service/app-python   LoadBalancer   10.101.64.112   <pending>     5000:32164/TCP   9m30s
service/kubernetes   ClusterIP      10.96.0.1       <none>        443/TCP          13d

NAME                                      STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
persistentvolumeclaim/data-app-python-0   Bound    pvc-b39a681a-0841-47da-afcf-e628c6796587   1Gi        RWO            standard       82m
persistentvolumeclaim/data-app-python-1   Bound    pvc-89e7bf49-a404-49ee-ae19-2ffe5aa910c6   1Gi        RWO            standard       82m
```

I checked only recently created pods, not these from last lab which crashed:
```bash
 $ kubectl exec pod/app-python-0 -- cat data/visit_count.txt                                             
156                                                                                                                                          
$ kubectl exec pod/app-python-1 -- cat data/visit_count.txt
157
```

### Describe and explain differences in the report

There were more visits to the first pod than the second. The reason for the difference is most likely that the second pod only received healthcheck requests from the minikube service, which proxied most queries to the first pod. Maybe there was greater equality in the numbers if there was a load balance.

### Explain why ordering guarantees are unnecessary for your app

 App in my implementation does not require ordering guarantees because each pod operates independently of the others. We may therefore launch as many pods concurrently as we like.
